[TOC]



# LocalMapping总述

​		LocalMapping线程是system中创建3大线程时创建的，局部建图线程调用LocalMapping::Run函数，局部建图线程在创建之后运行，随主线程的结束一起结束。局部建图线程以Traccking流程插入关键帧为输入，目的是对地图的关键帧和地图点做出增删改和优化。以优化后的关键帧和地图点为输出，驱动闭环检测和地图更新。让地图和下一轮的跟踪更准确。

<img src="/home/hanbing/公共的/typora实验记录/assets/image-20231002160822097.png" alt="image-20231002160822097" style="zoom: 50%;" />

# 主函数 — LocalMapping::Run()

​		run函数是局部建图的主函数，也是线程的调用函数。函数主要有以下工作：其中2.3-2.6都是等待2.1中处理完*mlNewKeyFrames*中排队的待插入的关键帧后做的，也就是使用排队中最后一个关键帧新建、融合地图点。由于新建地图点时选择的共视关键帧比较多，所以新建地图点几乎不会有折损，所以之后的融合地图点，局部BA和冗余关键帧删除也没有影响。2.1,2.2,2.7是插入的每一个关键帧都做的。

![image-20231009112643677](/home/hanbing/公共的/typora实验记录/assets/image-20231009112643677.png)





## 第一步：表明建图线程正在繁忙

​		设置*mbAcceptKeyFrames*成员变量为false，表示当前局部建图进程繁忙。现在不太想接收关键帧，在tracking流程中判断是否插入关键帧需要考虑这个成员变量，当还没有到达插入关键帧的最大间隔时，如果建图线程正在繁忙，那么就不插入关键帧。但是如果已经大于插入关键帧的最大间隔了，那么还是要插入关键帧到*mlNewKeyFrames*列表中排队。

<img src="/home/hanbing/公共的/typora实验记录/assets/image-20231008194911654.png" alt="image-20231008194911654" style="zoom: 80%;" />

​		在Tracking中判断是否插入关键帧时考虑：

<img src="/home/hanbing/公共的/typora实验记录/assets/image-20231008194021960.png" alt="image-20231008194021960" style="zoom: 67%;" />

### 成员变量

| LocalMappinig类     | 类型 | 意义                     | 补充说明                                               |
| ------------------- | ---- | ------------------------ | ------------------------------------------------------ |
| *mbAcceptKeyFrames* | bool | 表示当前建图线程是否繁忙 | 在Tracking流程中判断是否插入关键帧需要考虑这个成员变量 |

### 

## 第二步：对排队列表中的关键帧做局部建图环节

​		这是整个局部建图线程的核心，首先检查待插入列表中是否有关键帧排队，如果有，那么就进入到处理环节，一共有7项处理流程。==2.3-2.6都是2.1中处理完排队的关键帧了再去做的。2.1,2.2和2.7是对每个新插入的关键帧都进行的操作==。



## 2.1 处理排队列表中的关键帧——ProcessNewKeyFrame()

​		当一个普通帧蜕变为关键帧时，它就需要有更多的羁绊。关键帧应该具备的素质和属性一个也跑不掉。第一步，关键帧必须要有词袋向量的表示。第二步，由于插入了新的关键帧，地图点的观测索引、代表性描述子、平均观测方向和观测距离范围需要更新。第三步，基于地图点的观测索引，关键帧的共视图需要更新。第四步，把这个关键帧插入地图。

- 第一步，计算该关键帧特征点的词袋向量*（BowVector和FeatureVector）*；
- 第二步，由于地图点被新的关键帧观测到了，所以地图点的一些属性需要更新。给当前关键帧在Tracking流程跟踪到的地图点，添加至当前帧的观测索引mObservations。并基于更新后观测索引更新该地图点的平均观测方向、观测距离范围和代表性描述子；
- 第二步，如果有观测索引，那么把这些新建的点放在mlpRecentAddedMapPoints中等待检查和剔除。==这个只发生在单双目初始化和双目新插入关键帧时，因为新生成了地图点且建立了地图点的观测索引==。然而 ，跟踪环节跟踪到的地图点只是注册到了mvpMapPoints成员变量中，并没有建立观测索引和插入地图。因此这部分流程主要是把单双目初始化和双目新插入关键帧时新建的地图点放入mlpRecentAddedMapPoints变量中（单目Tracking中新插入关键帧时没有新建地图点）
- 第三步，更新关键帧之间的共视关系（共视图），维护那三个关键的共视变量。共视关系很重要！在Tracking的重定位、跟踪局部地图和LocalMapping的剔除冗余关键帧以及闭环流程中都有用到。
- 第四步，把关键帧插入地图。

<img src="/home/hanbing/公共的/typora实验记录/assets/image-20231008203313698.png" alt="image-20231008203313698" style="zoom:67%;" />

## 

## 2.2检查*mlpRecentAddedMapPoint*并剔除不好的地图点——MapPointCulling()

​		新增地图点会备份在mlpRecentAddedMapPoint临时变量中，本步骤就是检查备份的新增地图点列表，如果检查合格那么以后就不再检查了，然后把地图点从该备份列表中删除；如果不合格，那就把地图点从关键帧和地图中剔除，并删除地图点内存，然后把地图点从该备份列表中删除。

### 检查的项目和剔除的标准：

1. **情况1：地图点为bad**

    ​		该地图点已经设置为bad了，不管它，地图点为bad之后在其他地方都会受到检查被用到，直接从备份列表中剔除。

2. **情况2：跟踪比例不达标：(mnFound)/mnVisible <0.25**

    ​		地图点的mnFound和mnVisible成员变量是在跟踪局部地图中维护的。mnVisible表示我们认为这个地图点能够成功跟踪上的次数；mnFound表示实际跟踪上的次数。如果在跟踪局部地图环节，某一个地图点总能够投影到别的帧上，却只有极少次能够实际跟踪上，那么说明这个地图点不靠谱，应该从地图中剔除掉，然后再从备份列表中去除。

3. **情况3：关键帧观测不稳定**

    ​        从该点建立开始，已经过去不少于两个关键帧，但是观测到该点的关键帧数nObs却不超过给定阈值，那么从地图中剔除该点，然后再从备份列表中去除。这一步使用地图点的Observations()函数获得成员变量nObs，表示观测到该地图点的关键帧数量。nObs与上面的mnFound和mnVisible区别为前者是跟踪环节之后的针对关键帧的观测关系 后者则是对所有帧在跟踪环节中的跟踪关系。

4. **情况4：好地图点**

    ​		从该点建立开始，已经过去三个关键帧了而没有被删除，认为是质量较高的点。从备份列表中去除不再进行检查。

​		*mlpRecentAddedMapPoint*成员变量的说明：在Run()函数的第2.2步中剔除（也就是本步）。在Run()函数的第2.1步和第2.3步中添加。其中第2.1步中备份在单双目初始化和双目插入新关键帧时新建的地图点；2.3步中，把新建的点备份至这个变量中接受检查。

### 成员变量

| LocalMappinig类          | 类型                       | 意义                                                       | 补充说明                                                     |
| ------------------------ | -------------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| *mlpRecentAddedMapPoint* | std::list<br /><MapPoint*> | 新增地图点的备份列表（用于被检查和剔除）                   | 是先增加地图点再备份至这个成员变量中，然后接受检查。不合格的要从地图中剔除，合格的就不剔除。 局部建图流程的2.2环节MapPointCulling()就通过这个变量检查和剔除质量不好的新增地图点。 局部建图流程的2.1环节，把单双目初始化和双目插入关键帧时新建的点备份至这个变量中接受检查。 局部建图流程的2.3环节，把新建的点备份至这个变量中接受检查。 |
| *mlNewKeyFrames*         | std::list<KeyFrame*>       | 待插入关键帧的列表，还作为一种标志                         | 从Tracking传入的需要插入的关键帧列表，局部建图流程按照这个列表依次插入和地图增删改优化。这个变量通过CheckNewKeyFrame()函数调用，目的是查看现在还有没有在排队的待插入关键帧。局部建图流程中 2.3-2.6比较耗时，都是处理完排队才做的。因此这个成员变量，还作为一种标志。 |
| **MapPoint类**           | **类型**                   | **意义**                                                   | **补充说明**                                                 |
| mnFound                  | int                        | 表示该地图点实际跟踪上的次数（帧数量，包含关键帧和普通帧） | 跟踪局部地图时维护。在局部地图跟踪结束后，如果成功跟踪某个地图点，那么该地图点的mnFound++。 |
| mnVisible                | int                        | 表示我们认为这个地图点能够成功跟踪上的次数                 | 跟踪局部地图时维护。如果某个地图点在局部地图跟踪之前的三大跟踪环节就已经跟踪到 或者 在局部地图跟踪环节中作为局部地图点成功投影到当前帧上，那么这个地图点的mnVisible++。 |
| nObs                     | int                        | 观测到该地图点的关键帧数量                                 | 每当地图点添加观测关系AddObservation()，便使nObs++。只有单双目初始化、双目插入新关键帧和局部建图时维护。 与mnFound和Visible的区别，普通帧在跟踪过程中就能够维护mnFound和mnVisible，但是nObs是针对于关键帧的。能够添加观测关系的，都是关键帧，添加观测关系也意味着为地图点建图。 |

## 

## 2.3 与一级共视关键帧创建新地图点——CreateNewMapPoints()

### 为什么要新建地图点？

​		只有地图点被建立并且被插入到关键帧和地图中后，才能够被跟踪流程跟踪到。地图点第一次被建立是在初始化的时候，因此在SLAM中需要不断插入关键帧并基于关键帧的特征匹配不断增量的插入地图点，才能够确保后续跟踪的稳定性和地图表达的精确性。

### 思路

**首先：**根据*mvpOrderedConnectedKeyFrames*获得共视权重从大到小排列的前nn个共视关键帧。

​		下面就使用这些关键帧依次和当前帧特征匹配和新建地图点。也就是说，新建出来的地图点，并不是按照每一个新插入的帧和他之前的一帧三角化而来的，而是采用一种更稠密的方式，使用当前插入的关键帧，和他的一部分共视关键帧都进行地图点的恢复。（并不是所有新插入的关键帧都会有机会恢复地图，是选择某一段时间插入的最后一个关键帧来恢复，因为这个流程比较费时，所以系统会先把新插入的关键帧处理好再进行建图）

**其次：**遍历共视关键帧，使用当前帧与其构造为两帧，进行特征匹配，为恢复地图点做准备。

​		并不是所有的共视关键帧都可以用来恢复地图点，有些共视关键帧和当前帧的基线太短（单双目有各自的判断方法）就不能拿来恢复地图，应该要舍弃。基线过关之后，就计算两帧之间的基础矩阵，再进行DBoW加速的特征匹配，基础矩阵用来构造极线剔除离群点。

**最后：**遍历匹配点对，根据视差角情况恢复地图点，检查地图点，注册地图点。

​		恢复：遍历匹配成功的点对，先计算他们的视差角。如果视差角太小，则恢复地图点会有很大误差，这个时候对于单目只能舍弃这个匹配点，对于双目/RGBD的话可以使用本身得到的深度恢复。如果视差角比较大，那么无论单目和双目都使用三角化恢复。

​		检查：对于恢复出来的地图点，需要接受三个检查关卡，1.地图点必须在相机的前面(深度>0)  2.重投影误差在卡方阈值之内 3.该地图点对于两个帧的深度比例 应该与 两帧对应特征点的金字塔层数系数比例相近。

​		注册：成功过关的3D点，就要成为一个真正的地图点啦，因此他也要更新属于地图点对象的专属羁绊。包括添加观测索引，地图点的代表性描述子计算平均观测方向和深度范围计算。然后插入关键帧和地图中，再放入备份列表*mlpRecentAddedMapPoint*等待地图点检查和剔除步骤MapPointCulling()的降临。

<img src="/home/hanbing/公共的/typora实验记录/assets/qq_pic_merged_1696948206908.jpg" alt="qq_pic_merged_1696948206908" style="zoom: 65%;" />

### 成员变量

| LocalMapping类               | **类型**               | **意义**           | **补充说明**                                                 |
| ---------------------------- | ---------------------- | ------------------ | ------------------------------------------------------------ |
| *mlNewKeyFrames*             | std::list<KeyFrame*>   | 待插入关键帧的列表 | 从Tracking传入的需要插入的关键帧列表，局部建图流程按照这个列表依次插入和地图增删改优化。这个变量通过CheckNewKeyFrame()函数调用，目的是查看现在还有没有在排队的待插入关键帧。局部建图流程中 2.3-2.6比较耗时，都是处理完排队才做的。因此这个成员变量，还作为一种标志。 |
| **KeyFrame类**               | **类型**               | **意义**           | **补充说明**                                                 |
| mvpOrderedConnectedKeyFrames | std::vector<KeyFrame*> |                    |                                                              |
| Ow                           | cv::Mat                | 光心               |                                                              |

### step 1 获得一级共视帧——GetBestCovisibilityKeyFrames()

​		通过当前观测帧的共视关系，通过访问*mvpOrderedConnectedKeyFrames*成员变量，获得共视权重从大到小排列的前nn个共视关键帧，作为新增地图点KF2。

### step 2 遍历共视帧，构造两帧

​		当前关键帧逐每一个共视帧，构造成一对帧。这一对帧用于后面的特征匹配和三角化流程。

### step 3 判断两帧基线是否足够长

​		基线的长短，影响着地图点恢复的精度；如果基线太短，那么误差会很高。所以需要对构造的两帧基线作出判断。使用两帧光心之间的距离作为基线长度。**对于双目情况，**直接拿两帧的基线长短和自身传感器基线比较，如果小于自身传感器基线，那么这对帧基线不行，换下一个共视帧构造。**对于单目情况**，先求解共视关键帧中地图点的中值深度（中位数），把基线和中值深度的比值作为判断基线是否足够长的标准，如果比值太小(<0.01)，那么说明这对帧基线不行，换下一个共视帧构造。

<img src="file:////home/hanbing/.config/QQ/nt_qq_8fd520cf964b05435dd14625633ac868/nt_data/Pic/2023-10/Ori/ea96d328508aacae21579b3b87472890.jpeg" alt="img" style="zoom:40%;" />

<img src="/home/hanbing/公共的/typora实验记录/assets/image-20231010114838934.png" alt="image-20231010114838934" style="zoom:50%;" />

#### 求解光心之间位姿时：两个位姿点的相对位姿的表示和运算

​		需要明白的是，已知两个位姿点相对于世界坐标系的位姿Taw和Tbw，从a到b或从b到a的相对位姿应该如何表示？某个位姿的逆如何求？看下面的公式，相信已经看明白了，下面来总结一下。

​		假如我们要求从位姿点b 到 位姿点a的相对位姿，那么该变换矩阵表示为Tab ，T的下标代表后面一个点到前面一个点的变换。而这个矩阵如何计算呢，可以记住一个口诀，就是前面的变换矩阵*后面的变换矩阵之逆，b到a的变换Tab就是Taw * Tbw -1 。b点位姿之逆如何求呢，就是b点的R取逆（反对称矩阵的逆=转置），t变为 R的逆 * t 。具体可以看下面的公式。



<img src="/home/hanbing/公共的/typora实验记录/assets/image-20231009211244280.png" alt="image-20231009211244280" style="zoom:67%;" />

### step 4 计算两帧的基础矩阵(已知Rt) —— ComputeF12(mpCurrentKeyFrame,pKF2);

​		计算两个帧之间的基础矩阵，目的是为了之后的特征匹配中，使用极线约束+卡方检验区分内外点（和单目初始化时操作一样）。使用t^ R的出本质矩阵，再根据公式通过本质矩阵得出基本矩阵。

### step 5 BoW正向索引加速特征点匹配，极点极线约束抑制离群点——SearchForTriangulation()

​		核心一句话概括为：使用Bow词袋加速 + 使用极点和阈值 + 基本矩阵的极线和卡方检验取分内外点。没有用到最优次优匹配的阈值和非主流方向直方图剔除。

​		利用正向索引，在同一个nodeID下，取出KF1的每一个**未跟踪**特征点，与KF2的所有**未跟踪**特征点计算距离，得到最佳匹配。最佳匹配经历两个筛选关卡。第一个是匹配的特征点到极点的距离在阈值内，第二个是匹配的特征点到极线的距离在卡方阈值内。极点是当前关键帧的光心投影到共视关键帧的坐标。极线是基本矩阵带有的属性，即一个特征点在另外一幅图像上的成像点一定在基础矩阵和该特征点相乘得到的直线上。

### step 6 遍历匹配点对，根据视差角情况恢复地图点，检查地图点，注册地图点。

​		这部分的核心在于恢复，检查和注册三个关键词，让我们一个个来解析。

### 6.1 6.2 6.3 恢复地图点		

​		首先是恢复，是根据当前匹配点对的视差角大小，选择合适的恢复方法。对于双目来说，视差角比较大那就使用三角化的方式恢复地图点，因为这时候恢复的点比较准，如果视差角小很小，就使用自身传感器计算出来的深度值恢复；对于单目来说，只能接受视差角比较大的情况，如果视差角太小，那就换下一对匹配点。

#### 视差角的求解

​		求解视差角的核心是把两个观测射线表示为向量后转化为一个坐标系下求解。首先把两个特征点反投影到各自的归一化成像平面中，这样就得到了两个向量，xn1,xn2中的值实际上代表他们所在直线的参数ax+by+z=0中的a和b。然后把两条直线都转化到世界坐标系的姿态，再通过求向量夹角的公式就能得到cos阿尔法。
$$
cos\alpha=(a1*a2+b1*b2)/\sqrt{(a1^2+b1^2)}\sqrt{(a2^2+b2^2)}
$$
<img src="/home/hanbing/公共的/typora实验记录/assets/image-20231010202024818.png" alt="image-20231010202024818" style="zoom: 75%;" />

#### 计算视差角时，转化姿态到世界坐标系，为什么没有使用Rt，而只用了R？

​		答：求视差角时不用使用t，因为平移是不改变夹角的。R的目的是把两个帧的射线（向量）转化为同一个姿态下观测，这样才能求视差角。假如有两个帧的向量，每一个帧在自己的角度下观测这个向量都是90度，想要求他们的视差角，就一定要转化到一个观测角度上。而使用R的目的就是，把它们都统一转换到世界坐标系的角度姿态下观测。

<img src="/home/hanbing/公共的/typora实验记录/assets/qq_pic_merged_1696940272248.jpg" alt="qq_pic_merged_1696940272248" style="zoom: 50%;" />

#### 三角化恢复地图点（视差角较大）

​		和初始化时一样，是通过构建最小二乘问题，用四个约束求三个未知数，然后用SVD分解求。在14讲中初始化部分写了推导过程。

#### 双目/RGBD恢复地图点（视差角较小）

​		在视差角比较小时，双目/RGBD不使用三角化，使用特征点反投影+传感器测出的深度值恢复，调用函数KeyFrame::UnprojectStereo(idx1)就可以得到对应索引的特征点深度。

### 6.4 地图点检测关卡

​		对于恢复出来的地图点，需要接受三个检查关卡，通关后才能添加到地图中，否则视为无效continue下一对匹配点。

1. 地图点必须在相机的前面(深度>0)  ：这个很好理解，地图点恢复出来发现深度是负数，那指定有毛病。

2. 重投影误差在卡方阈值之内 ：恢复出来的地图点在两个帧上都重投影，而且误差都要小于阈值。这里卡方阈值的取值依据是*自由度为2，假设条件认为误差不超过1个像素点，假设概率是99%*。

3. 该地图点对于两个帧的深度比例 应该与 两帧对应特征点的金字塔层数系数比例相近：

    ​        假设这两个特征点对应的是一个地图点，那么理论上他们的深度比例应该和金字塔层数系数比例相近。但是如果有两个路标点非常相似，但却不是一个，这时他们各自的特征点很相似，描述子很相似，结果他们的特征点被特征匹配到了一起，还被恢复出了一个虚无的新地图点，由于特征点对应的金字塔系数是真实的，而深度是恢复地图点之后计算的。那么这个时候他们的深度比例 与 特征点的金字塔层数系数比例 一定是差别很大的。所以这个条件可以筛选掉这种情况。

    但是我认为重投影误差那个条件基本上可以把这个情况也筛选了，所以感觉影响不大，后面Debug的时候自己试试。

### 6.5 注册地图点

​		注册：成功过关的3D点，就要成为一个真正的地图点啦，因此他也要更新属于地图点对象的专属羁绊。包括添加观测索引，地图点的代表性描述子计算平均观测方向和深度范围计算。然后插入关键帧和地图中，再放入备份列表*mlpRecentAddedMapPoint*等待地图点检查和剔除步骤MapPointCulling()的降临。	

**但是为什么关键帧内插入了新的地图点，却没有更新共视图呢？	**

**答：因为现在的观测关系还不是最终的，在地图点融合和新跟踪之后，才是这一轮新建地图点最终的样子，这时再更新。**

​		![image-20231011100711771](/home/hanbing/公共的/typora实验记录/assets/image-20231011100711771.png)



## 2.4 两级共视关键帧地图点融合和共视帧跟踪新建的地图点SearchInNeighbors()

==（神来之笔，太聪明了，既融合了地图点，又让两级的共视关键帧跟踪新建的地图点，这样一来更新的共视图就绝对正确）==

### 为什么要做，在做什么？

​		**一句话概括：融合+跟踪新建的地图点。拿2.3中用一级共视帧新建的地图点，与两级共视帧范围内的所有新建之前已有地图点融合和跟踪新建的地图点（正向+反向）。新建地图点之间不存在融合，因为新建是使用当前帧与其他每一个共视帧三角化，每当三角化该特征点就会被标记，不会再用于新建地图点**。

​		（融合）由于新建的地图点有一些是地图上本身就有的，只是这些关键帧没跟踪上。新建地图点时，一级共视关键帧在地图中没有跟踪到的那些地图点，如果恰好当前关键帧和共视关键帧都没有跟踪到那个地图点，他们在特征匹配的时候自然而然特征点就能匹配上，然后进行恢复地图点，这个时候恢复出来的地图点，不就是之前就已经在地图中存在的吗？所以要进行合并，把同一个地图点合并。合并之后重新插入关键帧，更新一下关键帧的对地图点的跟踪索引*mvpMapPoints[idx]=pMP*。然后地图点本身的属性，就用共视数量大的那个地图点更新和表示，最后再更新共视图。

​		（二级共视帧跟踪新建的地图点）除此之外，还有一个很重要的作用是，让二级共视关键帧跟踪上新建的这些地图点。由于之前的关键帧跟踪时地图中是没有这些新建的地图点的，所以可能存在新建的地图点原本应该被二级共视关键帧跟踪到。因此在Fuse()融合的过程中，发现匹配的关键帧特征点并没有对应地图点，那就把当前新建的地图点与特征点关联上，这样之后的共视图便更加准确。

<img src="/home/hanbing/公共的/typora实验记录/assets/IMG_20231011_171347(1).jpg" alt="IMG_20231011_171347(1)" style="zoom:10%;" />

### step 1 寻找两级共视关键帧

​		创建新地图点使用一级共视帧，而融合范围是二级共视帧。通过访问*mvpOrderedConnectedKeyFrames*成员变量，获得共视权重从大到小排列的前nn个一级共视关键帧。然后每个一级共视帧再找共视权重排前五的二级共视帧。一级和二级放在一起构成地图点融合局部范围（二级共视帧可能是当前帧自己，要剔除）

### step 2 正向投影匹配的方式融合——matcher.Fuse(每一个共视帧，当前帧地图点)

### step 3 反向投影匹配的方式融合——matcher.Fuse(当前帧  与所有两级共视帧总地图点)

​		地图点融合步骤的核心部分，可谓是相当精彩。这个过程包括正向和反向两个部分，但处理的流程是相同的，我们拿正向举例。

​		取出当前帧所有观测到的地图点（跟踪到的+新建的）与每一个二级共视关键帧进入Fuse函数做融合。这个函数的核心流程是：

1. 遍历地图点，如果在关键帧中已经观测到了这个地图点，那就剔除这个地图点（非常巧妙，剩下的地图点要么是需要被融合的，要么是可以让关键帧补充跟踪的）Ps：筛选的条件还包括地图点位姿变换过去深度值为正，观测深度范围和观测角度符合要求，投影过去得到的坐标uv与光心的距离达标等，详看代码。

2. 然后把传入的地图点在传入的关键帧上投影，筛选FeatureInArea范围内的特征点，对于筛选过关的特征点，使用描述子的距离寻找最优匹配。Ps：寻找最优匹配之前筛选范围内的特征点，主要包括：特征点所在的金字塔层数和地图点预测的差距较大，重投影误差大于卡方阈值。

3. 认为最优匹配的点和该地图点是一对点。

    如果最优匹配的特征点已经对应了地图点，认为是重复地图点，使用观测值大的那个地图点统一替代。替代该地图点的成员变量，更新该地图点的观测索引。

    如果最优匹配的特征点没有对应地图点，那么就添加上观测关系，更新该地图点的观测索引。

<img src="/home/hanbing/公共的/typora实验记录/assets/1697015791711.jpg" alt="1697015791711" style="zoom:13%;" />

### step 4	更新当前关键帧的地图点属性和共视图

​		新建地图点，在发生了融合和新跟踪后，他们的观测索引发生了变化，那么需要更新当前地图点的一些属性，包括计算代表性描述子、观测深度范围等等。最后也是非常重要的，就是根据更新后的观测关系，更新共视图。在这个共视图的更新，是新建地图点经过融合和新跟踪之后才更新的。

### 新建地图点时，把地图点放在了备份列表中检查，在融合之后有的地图点被替换了怎么办，检查会受到影响吗？

​		答：不会受到影响，因为在2.4的融合和新跟踪过程，只有融合的其中一部分的点被替换了，对于这一部分地图点来说，他们已经不在地图中了，因此在后续是不会被观测到的，会被删除内存并从备份列表中剔除。其他的点依旧正常的受到2.2流程的检查。



## 2.5 局部BA优化——LocalBundleAdjustment（剔除了外边对应的关键帧和地图点的投影关系，没有按道理需要更新地图点属性和关键帧的共视图，还差共视图和代表性描述子没更新）

​		**优化的变量是当前关键帧及其局部关键帧的位姿（后面简称Pose1）和地图点（MapPoint1）**。局部关键帧表示：当前关键帧的所有共视关键帧也称第一级共视帧。

​		**首先：**遍历所有能观测到MapPoint1的关键帧，把他们的位姿，都作为顶点放入图模型，把不是Pose1顶点设置为固定不优化，非固定的就剩下Pose1；（Ps：为什么要放进去呢？由于局部关键帧的地图点MapPoint1还被一些其他帧观测到，所以在为每一个地图点顶点添加边计算误差时，需要使用其他帧的位姿，所以在g2o框架中，就把这些其他帧的位姿也设为顶点，只不过把他们的值像初始位姿一样锁住不优化。目的就是为了添加边计算误差。）

​		**其次：**遍历MapPoint1，把其设为顶点；并通过GetObservations()方法获得观测到该地图点的顶点，逐个插入边；

​		**最后：**执行两阶段优化。第一阶段优化5轮，第一阶段优化之后，误差大于阈值的边设为外边，第二阶段不使用这个边优化。第二阶段优化10轮，第二阶段优化重新统计外边，把外边所对应的观测关系注销（关键帧和地图点）

### step 1 找到待优化的关键帧、待优化地图点和需固定位姿的其他帧并存放在向量中

1.1 找当前和其所有的共视关键帧作为==局部关键帧==（待优化）；

1.2 把当前和局部关键帧的地图点作为==局部地图点==（待优化）；

1.3 通过GetObservations()方法获得观测到局部地图点却不是局部关键帧的==其他关键帧==（不优化）。

​		这些其他关键帧的位姿也会被设为顶点，但将会被锁住，只用于添加边计算误差。Ps：GetObservations()能够得到 mObservations，std::map<KeyFrame*,size_t>  表示该地图点被哪些关键帧的哪个特征点跟踪到。

### step 2 构建图模型，添加顶点和边

​		常规的g2o流程，初始化图模型、线性求解器、Block求解器和优化器。然后插入顶点和边。这里插入顶点和边的时候有一些技巧，就是先把位姿点插进去，然后插入地图点，在每插入一个地图点的时候，利用他的观测索引GetObservations()找到所有的投影关系，建立一个循环插入所有的边，每一个边都是二元边。

### step 3 执行两阶段优化，找出外边，注销其投影关系

​		每一个阶段的优化之后都要找到误差大于阈值的外边（单目是2自由度的卡方阈值，双目是3自由度），不同的是，第一阶段找外边的目的是让他们不参与第二阶段的优化，让后续的优化更准确。第二阶段找外边的目的是，这些优化了15轮还烂泥扶不上墙的投影关系注销。

<img src="/home/hanbing/公共的/typora实验记录/assets/image-20231013142904071.png" alt="image-20231013142904071" style="zoom: 80%;" />

​		注意：这里发生了地图点和关键帧的观测关系改变，理应来说。需要更新地图点的属性（观测索引，代表性描述子，平均观测距离和方向）和关键帧的共视图。在EraseObservation中更新了观测索引、在下面step4中计算了平均观测距离和方向，==但是代表性描述子和共视图没有更新。==

### step 4 更新优化后的pose和mappoint

​		除了更新优化后的pose和mappoint，还更新了mappoint的平均观测距离和方向（由于有的观测关系发生了删减）



## 2.6 剔除冗余局部关键帧——KeyFrameCulling()

​		剔除冗余局部关键帧（当前帧的所有共视帧被称为局部帧），如果这些关键帧中看到的90%的 MapPoints都能被其他不少于三个关键帧看到，那么认为这个关键帧是冗余的。剔除该冗余关键帧的同时更新共视图。 	

## 2.7将当前帧加入到闭环检测队列中

​		通过回环检测类的InsertKeyFrame函数激活回环检测流程。当前关键帧会被插入到回环检测的成员变量mlpLoopKeyFrameQueue中。这个成员变量和Tracking插入局部建图线程时的mlNewKeyFrame成员变量很像。

![image-20231013165901845](/home/hanbing/公共的/typora实验记录/assets/image-20231013165901845.png)

![image-20231013165839948](/home/hanbing/公共的/typora实验记录/assets/image-20231013165839948.png)

## 第三步：查看是否有复位线程的请求

## 第四步：表明局部建图线程目前是空闲的

​		处理完了这些关键帧，完成了局部BA和荣誉关键帧晒筛除，目前局部建图线程是空闲的。设置mbAcceptKeyFrames成员变量为ture，告诉Tracking，现在插入关键帧的要求变轻松了。

​		表示当前的空闲状态，然后挂起3ms，等待关键帧的插入。如果一直没有关键帧插入，那么绝大部分时间mbAcceptKeyFrames成员变量都是ture，也就是空闲的。虽然上面第一步设置了mbAcceptKeyFrames成员变量为false，但是代码运行的是很快的，在空闲状态usleep3000占据了绝大部分的时间，就不会导致状态频繁改变，只有当关键帧插入时处理关键帧的时候，繁忙时间才会占据。

![image-20231013194228054](/home/hanbing/公共的/typora实验记录/assets/image-20231013194228054.png)

## 第五步：设置局部建图子线程已经终止，SetFinish()

​		如果需要局部建图线程终止（比如主线程结束时），那么会通过改变局部建图的mbFinishRequested成员变量来给予命令，在局部建图的while(1)环节中，会通过CheckzaiFinish()查看该成员变量的值，如果有命令，那么会直接跳出循环进入第五步，将线程终止。



## 需要学习和特别重要的

### 有关键帧插入之后，局部建图流程对关键帧和地图点的操作有哪些？

​		**在2.1中，新增了待插入关键帧和其跟踪到的地图点**

​		会把新关键帧中跟踪到的地图点插入地图，升级他们的跟踪关系(只在关键帧的地图点容器中注册vpMapPointMatches)。给他们==观测索引(AddObservation)==，并且由于更新了观测索引，再更新他们的==平均观测方向和深度(UpdateNormalAndDepth)==以及==代表性描述子(ComputeDistinctiveDescriptors)==,由于插入了新的关键帧和地图点，所以还要==更新共视图(UpdateConnections)==

​		**在2.2中，删除了地图点**

​		单双目初始化、双目新插入关键帧和局部建图线程中新建的地图点都要备份在检查列表中*mlpRecentAddedMapPoint*，用于检查该地图点的合理性。如果地图点不太好，在这一步需要从地图中剔除，也会==清除该地图点的索引关系==，将对应关键帧的==vpMapPointMatches对应值设置为NULL==。因此后面还需要更新共视图，但是在2.2中没有更新，是在2.4中更新的，目的是为了局部BA。

​		**在2.3中，新增了地图点**

​		如果局部建图流程处理到当前待插入关键帧序列的最后一个关键帧时，就会基于该帧进行地图点新建。使用当前帧和其共视程度排名前nn的每一个共视帧重建，对于合格共视帧(基线足够长)使用**DBoW特征匹配**，并使用极线和极点筛选内外点得到匹配点对。基于匹配点对的视差角选择使用三角化或**双目传感深度恢复**。对于重建合格(重投影误差、深度为正、尺度连续性)的3D点，注册成为地图点，给他们==观测索引(AddObservation)==，并且由于更新了观测索引，再更新他们的==平均观测方向和深度(UpdateNormalAndDepth)==以及==代表性描述子(ComputeDistinctiveDescriptors)==。因此后面还需要更新共视图，但是在2.3中没有更新，是在2.4中更新的，目的是为了局部BA。

​		**在2.4中，融合了地图点，新增了观测关系（地图点新被跟踪了）**

​		在2.3中，如果当前帧和共视帧都没有跟踪到某个地图中已有的地图点，那么他们在新建地图点时，很大概率会重建出来这个地图点，所以这将导致和以前地图点的重复。同时，由于2.3中新增的地图点是在共视帧跟踪的未来出现的，因此这些共视帧将无法跟踪到新建的地图点。在2.4中，就是为了把重复的地图点融合和打通时空让过去的帧跟踪上未来的点。

​		2.4使用当前帧共视程度排名前nn的一级共视帧及其共视程度排名前5的二级关键帧作为融合范围。使用当前帧观测到的所有地图点逐个与融合范围的每一个共视帧做**投影匹配**。对于成功投影匹配上的特征点，如果其已经注册了地图点，那么认为这两个地图点是一个，使用被观测数多的那个统一替换，在Replace中更新了==观测索引(AddObservation)==、==代表性描述子(ComputeDistinctiveDescriptors)==和观测数量mfound，mVisible等；如果还没有注册地图点，那么就补充注册这个地图点，更新了==观测索引(AddObservation)==。在2.4的最后统一更新这些地图点的==平均观测方向和深度(UpdateNormalAndDepth)==以及==代表性描述子(ComputeDistinctiveDescriptors)==，并更新了==共视图(UpdateConnections)==。

​		**在2.5中，删除了观测关系（基于误差超出阈值的外边）**

​		在局部BA的过程，有一些边会被判定为离群边，说明这个观测关系不可靠。因此在地图中需要删除这一段观测关系，从关键帧中取消这个地图点的跟踪(*mvpMapPoints,把该地图点设为NULL*)，从地图点中==取消这个关键帧的观测索引(AddObservation)==，并更新了地图点的==平均观测方向和深度(UpdateNormalAndDepth)==。**共视图和代表性描述子没有更新，**虽然这里观测关系删除的比较少，但没有更新共视图，对下面的参考关键帧跟踪和局部地图跟踪还是有一些小影响的。

​		**在2.6中，删除了关键帧**

​		在剔除冗余关键帧中，把关键帧设置为了bad，并在SetBadFlag函数中更新了==共视图==，==注销了该关键帧中地图点观测索引(EraseObservation)==，但是**地图点的代表性描述子和平均观测方向和深度没有更新**。













**Fuse匹配中的Replace  和  2.6的SetBadFlag()好好看看**

**Fuse匹配中的Replace  和  2.6的SetBadFlag()好好看看**

**Fuse匹配中的Replace  和  2.6的SetBadFlag()好好看看**

**Fuse匹配中的Replace  和  2.6的SetBadFlag()好好看看**

**Fuse匹配中的Replace  和  2.6的SetBadFlag()好好看看**

**Fuse匹配中的Replace  和  2.6的SetBadFlag()好好看看**

**Fuse匹配中的Replace  和  2.6的SetBadFlag()好好看看**

### 代表性描述子和平均观测方向和深度有什么用？在哪里用？

代表性描述子和平均观测方向和深度有什么用？在哪里用？

代表性描述子和平均观测方向和深度有什么用？在哪里用？

代表性描述子和平均观测方向和深度有什么用？在哪里用？

代表性描述子和平均观测方向和深度有什么用？在哪里用？

代表性描述子和平均观测方向和深度有什么用？在哪里用？

代表性描述子和平均观测方向和深度有什么用？在哪里用？

代表性描述子和平均观测方向和深度有什么用？在哪里用？

### 

### 局部建图是什么时候暂停的stop？什么时候终止的finish？

### LocalMapping线程涉及的成员变量

| LocalMappinig类                  | 类型                 | 意义                                                       | 补充说明                                                     |
| -------------------------------- | -------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| mbStopRequested                  | bool                 |                                                            |                                                              |
| mbStopped                        | bool                 | 局部建图线程暂停的标志                                     |                                                              |
| mbAbortBA                        | bool                 |                                                            |                                                              |
| mbFinishRequested                | bool                 | 请求局部线图线程结束的标志                                 |                                                              |
| mbFinished                       | bool                 | 局部线图线程结束的标志                                     |                                                              |
| mbResetRequested                 | bool                 | 请求复位线程的标志                                         |                                                              |
| *mbAcceptKeyFrames*              | bool                 | 表示当前建图线程是否繁忙                                   | 在Tracking流程中判断是否插入关键帧需要考虑这个成员变量       |
| *mlNewKeyFrames*                 | std::list<KeyFrame*> | 待插入关键帧的列表                                         | 从Tracking传入的需要插入的关键帧列表，局部建图流程按照这个列表依次插入和地图增删改优化 |
| *mlpRecentAddedMapPoint*（重要） | std::list<MapPoint*> | 新增地图点的备份列表（用于被检查和剔除）                   | 是先增加地图点再备份至这个成员变量中，然后接受检查。不合格的要从地图中剔除，合格的就不剔除。<br />局部建图流程的2.2环节MapPointCulling()就通过这个变量检查和剔除质量不好的新增地图点。<br />局部建图流程的2.1环节，把双目/RGBD初始化和插入关键帧时新建的点备份至这个变量中接受检查。<br />局部建图流程的2.3环节，把新建的点备份至这个变量中接受检查。 |
| **MapPoint类**                   | **类型**             | **意义**                                                   | **补充说明**                                                 |
| mnFound                          | int                  | 表示该地图点实际跟踪上的次数（帧数量，包含关键帧和普通帧） | 跟踪局部地图时维护。在局部地图跟踪结束后，如果成功跟踪某个地图点，那么该地图点的mnFound++。 |
| mnVisible                        | int                  | 表示我们认为这个地图点能够成功跟踪上的次数                 | 跟踪局部地图时维护。如果某个地图点在局部地图跟踪之前的三大跟踪环节就已经跟踪到 或者 在局部地图跟踪环节中作为局部地图点成功投影到当前帧上，那么这个地图点的mnVisible++。 |
| nObs                             | int                  | 观测到该地图点的关键帧数量                                 | 每当地图点添加观测关系AddObservation()，便使nObs++。只有单双目初始化、双目插入新关键帧和局部建图时维护。<br />与mnFound和Visible的区别，普通帧在跟踪过程中就能够维护mnFound和mnVisible，但是nObs是针对于关键帧的。能够添加观测关系的，都是关键帧，添加观测关系也意味着为地图点建图。 |
|                                  |                      |                                                            |                                                              |
| **KeyFrame类**                   | **类型**             | **意义**                                                   | **补充说明**                                                 |
| mvpOrderedConnectedKeyFrames     |                      |                                                            |                                                              |
| Ow                               |                      |                                                            |                                                              |





# LoopClosing总述



# 主函数——LoopClosing::Run()

